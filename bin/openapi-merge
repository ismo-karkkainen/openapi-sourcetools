#!/usr/bin/env ruby
# frozen_string_literal: true

# Copyright © 2021 Ismo Kärkkäinen
# Licensed under Universal Permissive License. See LICENSE.txt.

require_relative '../lib/common.rb'
require 'optparse'
require 'yaml'
require 'json'
require 'set'


default_env(:out, '')
default_env(:format, 'YAML')
default_env(:prune, true);

ENV['POSIXLY_CORRECT'] = '1'
parser = OptionParser.new do |opts|
  opts.summary_indent = '  '
  opts.summary_width = 26
  opts.banner = 'Usage: openapi-merge [options] sources...'
  opts.separator ''
  opts.separator 'Options (equivalent environment variable and value in parentheses):'
  opts.on('-o', '--output FILE', 'Output result to FILE, not stdout (OUT=FILE).') do |f|
    env(:out, f)
  end
  opts.on('-k', '--keep', 'Keep all unreferenced objects under components.') do
    env(:prune, false)
  end
  opts.on('-p', '--prune', 'Prune all unreferenced objects under components (default).') do
    env(:prune, true)
  end
  opts.on('--yaml', 'Output format is YAML (default).') do
    env(:format, 'YAML')
  end
  opts.on('--json', 'Output format is JSON.') do
    env(:format, 'JSON')
  end
  opts.on('-h', '--help', 'Print this help and exit.') do
    $stdout.puts %(#{opts}

Source files are combined to form one API specification document. Sources are
allowed only to append to the merged document, not re-define anything in it.
)
    exit 0
  end
end
parser.parse!

aargh("Format neither JSON nor YAML: #{env(:format)}", 1) unless %w[JSON YAML].include? env(:format)

def read_source(filename)
  YAML.safe_load(File.read(filename))
rescue Errno::ENOENT => e
  aargh("Could not read #{filename}", 2)
rescue StandardError => e
  aargh(e.to_s, 3)
end

def raise_se(message)
  raise StandardError, message
end

def path_combo(path, prefix = true)
  if prefix
    path.empty? ? 'at root' : "under #{path.join('.')}"
  else
    path.empty? ? 'root' : path.join('.')
  end
end

def too_deep(path, max_depths)
  return false if path.empty?
  max_depths.fetch(path.first) <= path.size
end

def add_undefined(merged, incoming, filename, path, max_depths)
  incoming.each_pair do |key, value|
    unless merged.has_key? key
      merged[key] = value
      next
    end
    m = merged[key]
    raise_se "Path #{path_combo(path, false)} merged type #{m.class} differs from type #{value.class} in #{filename}" unless m.class == value.class
    raise_se("Re-definition of #{key} #{path_combo(path)} in #{filename}") if too_deep(path, max_depths)
    if m.is_a? Hash # paths or similar
      path.push key
      add_undefined(m, value, filename, path, max_depths)
      path.pop
    elsif m.is_a? Array
      value.each do |v|
        next if m.include? v
        m.push v
      end
    else
      raise_se "Re-definition of #{key} #{path_combo(path)} in #{filename}"
    end
  end
rescue StandardError => e
  aargh(e.to_s, 3)
end

max_depths = Hash.new(0)
max_depths['openapi'] = 1
max_depths['info'] = 1
max_depths['servers'] = 1
max_depths['paths'] = 2 # Allows get, post, options, etc. from different files.
max_depths['webhooks'] = 2
max_depths['components'] = 2
max_depths['security'] = 1
max_depths['tags'] = 1
merged = {}
ARGV.each do |filename|
  add_undefined(merged, read_source(filename), filename, [], max_depths)
end

def gather_refs(doc, found)
  doc.each_pair do |key, value|
    if key == '$ref' && value.is_a?(String) && value.start_with?('#/components/')
      found.add(value)
    elsif value.is_a? Hash
      gather_refs(value, found)
    elsif value.is_a? Array
      value.each do |v|
        gather_refs(v, found) if v.is_a? Hash
      end
    end
  end
end

if env(:prune)
  prev_refs = Set.new
  loop do # May have references from deleted so repeat until nothing deleted.
    refs = Set.new
    gather_refs(merged, refs)
    merged.fetch('security', []).each do |sec|
      sec.each_key do |key|
        refs.add("#/components/securitySchemes/#{key}")
      end
    end
    used = {}
    all = merged.fetch('components', {})
    refs.each do |ref|
      p = ref.split('/')
      p.shift(2)
      item = all
      p.each do |key|
        item = item.fetch(key, nil)
        break if item.nil?
      end
      next if item.nil?
      sub = used
      p.each_index do |k|
        if k + 1 < p.size
          sub[p[k]] = {} unless sub.has_key? p[k]
          sub = sub[p[k]]
        else
          sub[p[k]] = item
        end
      end
    end
    merged['components'] = used
    break if refs == prev_refs
    prev_refs = refs
  end
end

output = env(:out)
if output.empty?
  output = $stdout
else
  begin
    output = File.open(output, 'w')
  rescue StandardError
    aargh("Failed to open for writing: #{output}", 1)
  end
end

case env(:format)
when 'JSON' then output.puts JSON.generate(merged)
when 'YAML' then output.puts YAML.dump(merged)
end
output.close
